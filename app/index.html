<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MediaPipe</title>
  <link href="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.css" rel="stylesheet">
  <script src="https://unpkg.com/material-components-web@latest/dist/material-components-web.min.js"></script>
  <style>
    body {
      font-family: roboto;
      margin: 0;
      color: #3d3d3d;
      --mdc-theme-primary: #007f8b;
      --mdc-theme-on-primary: #f1f3f4;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f5f5f5;
    }

    .container {
      width: 100%;
      max-width: 768px;
      padding: 1em;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      background-color: #ffffff;
      border-radius: 20px;
      border: 16px solid #ccc;
      text-align: center;
    }

    h1 {
      color: #007f8b;
    }

    h2 {
      clear: both;
    }

    em {
      font-weight: bold;
    }

    video {
      clear: both;
      display: block;
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
      -moz-transform: rotateY(180deg);
    }

    section {
      opacity: 1;
      transition: opacity 500ms ease-in-out;
    }

    .removed {
      display: none;
    }

    .invisible {
      opacity: 0.2;
    }

    .note {
      font-style: italic;
      font-size: 130%;
    }

    .videoView,
    .detectOnClick {
      position: relative;
      width: 100%;
      margin: 2% 0;
      cursor: pointer;
    }

    .videoView p,
    .detectOnClick p {
      position: absolute;
      padding: 5px;
      background-color: #007f8b;
      color: #fff;
      border: 1px dashed rgba(255, 255, 255, 0.7);
      z-index: 2;
      font-size: 12px;
      margin: 0;
    }

    .highlighter {
      background: rgba(0, 255, 0, 0.25);
      border: 1px dashed #fff;
      z-index: 1;
      position: absolute;
    }

    .canvas {
      z-index: 1;
      position: absolute;
      pointer-events: none;
    }

    .output_canvas {
      transform: rotateY(180deg);
      -webkit-transform: rotateY(180deg);
      -moz-transform: rotateY(180deg);
    }

    .detectOnClick {
      z-index: 0;
    }

    .detectOnClick img {
      width: 100%;
    }

    .option {
      display: none;
    }
    select#inputType {
  padding: 10px;
  font-size: 16px;
  border-radius: 5px;
  border: 2px solid #007f8b;
  background-color: #f0f8ff;
  color: #007f8b;
  margin-bottom: 20px;
}

select#inputType:focus {
  outline: none;
  border-color: #005f6b;
}

button#webcamButton, input[type="file"] {
  display: block;
  width: 100%;
  max-width: 300px;
  margin: 10px auto;
  padding: 10px;
  font-size: 16px;
  border: none;
  border-radius: 5px;
  background-color: #007f8b;
  color: #fff;
  cursor: pointer;
  transition: background-color 0.3s ease;
}

button#webcamButton:hover, input[type="file"]:hover {
  background-color: #005f6b;
}

button#webcamButton:focus, input[type="file"]:focus {
  outline: none;
  background-color: #005f6b;
}
#liveView {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}

#liveView video, #liveView canvas {
  max-width: 100%;
  height: auto;
  margin: 0 auto;
}
/* Estiliza o botão de calcular */
.mdc-button--raised {
  background-color: #007f8b; /* Cor de fundo azul */
  color: #f1f3f4; /* Cor do texto branca */
  border-radius: 4px; /* Bordas arredondadas */
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2); /* Sombra do botão */
  font-size: 14px; /* Tamanho da fonte */
  padding: 12px 16px; /* Espaçamento interno do botão */
  margin-top: 20px; /* Espaçamento superior */
}

.mdc-button--raised:hover {
  background-color: #005f70; /* Cor de fundo azul escuro ao passar o mouse */
}

.mdc-button--raised:focus {
  outline: none; /* Remove a borda padrão de foco */
  box-shadow: 0 0 0 2px #00bcd4; /* Adiciona uma borda azul ao foco */
}

.mdc-button__label {
  font-weight: 500; /* Peso da fonte */
}

    @media (max-width: 768px) {
      .container {
        padding: 0.5em;
        border-width: 8px;
      }

      h1 {
        font-size: 1.5em;
      }

      h2 {
        font-size: 1.2em;
      }

      .note {
        font-size: 100%;
      }
    }
  </style>
</head>
<body>
  <section id="demos" class="invisible">
  <div class="container">
    <h1>Detector de Pose</h1>
    <select id="inputType" onchange="toggleInputType()">
      <option value="file">Carregar Arquivo</option>
      <option value="camera">Usar Câmera</option>
    </select>
    <div id="fileInput" class="option">
      <input type="file" id="inputFile">
      <div class="detectOnClick">
        <div id="imageContainer" style="display: none;">
          <img id="imagePreview" src="#" alt="Imagem Selecionada">
        </div>
        <button id="calculateFileButton" class="mdc-button mdc-button--raised">
            <span class="mdc-button__ripple"></span>
            <span class="mdc-button__label">Calcular</span>
          </button>
          <h4 id="med-ombro"></h4>
      </div>
    </div>
    <div id="cameraInput" class="option">
      <div id="liveView" class="videoView">
        <button id="webcamButton" class="mdc-button mdc-button--raised">
          <span class="mdc-button__ripple"></span>
          <span class="mdc-button__label">Autorizar WEBCAM</span>
        </button>
        <div style="position: relative;">
          <video id="webcam" style="width: 100%; height: auto;" autoplay playsinline></video>
          <canvas class="output_canvas" id="output_canvas" style="position: absolute; left: 0; top: 0;"></canvas>
          <h4 id='ShowCalcOmbro'></h4>
        </div>
        <button id="calculateCameraButton" class="mdc-button mdc-button--raised">
            <span class="mdc-button__ripple"></span>
            <span class="mdc-button__label">Calcular</span>
        </button>
      </div>
    </div>
  </div>
  </section>
  <script>
    function toggleInputType() {
      const inputType = document.getElementById('inputType').value;
      const fileInput = document.getElementById('fileInput');
      const cameraInput = document.getElementById('cameraInput');
      
      if (inputType === 'file') {
        fileInput.style.display = 'block';
        cameraInput.style.display = 'none';
      } else {
        fileInput.style.display = 'none';
        cameraInput.style.display = 'block';
      }
    }
    
    document.getElementById('inputFile').addEventListener('change', function(event) {
      const file = event.target.files[0]; // Obter o primeiro arquivo selecionado
      if (file) {
        const reader = new FileReader(); // Criar um FileReader para ler o conteúdo do arquivo
        reader.onload = function(e) {
          const imageSrc = e.target.result; // Obter o URL da imagem carregada
          const imagePreview = document.getElementById('imagePreview');
          imagePreview.src = imageSrc; // Definir o atributo 'src' da tag img para o URL da imagem
          document.getElementById('imageContainer').style.display = 'block'; // Exibir a div que contém a imagem
        };
        reader.readAsDataURL(file); // Ler o arquivo como um URL de dados
      }
    });

    toggleInputType(); // Chama a função ao carregar a página para definir a exibição inicial
  </script>
  <script type="module">
    // Copyright 2023 The MediaPipe Authors.
    // Licensed under the Apache License, Version 2.0 (the "License");
    // you may not use this file except in compliance with the License.
    // You may obtain a copy of the License at
    //
    //      http://www.apache.org/licenses/LICENSE-2.0
    //
    // Unless required by applicable law or agreed to in writing, software
    // distributed under the License is distributed on an "AS IS" BASIS,
    // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    // See the License for the specific language governing permissions and
    // limitations under the License.
    import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.skypack.dev/@mediapipe/tasks-vision@0.10.0";

const demosSection = document.getElementById("demos");
let poseLandmarker = undefined;
let runningMode = "IMAGE";
let enableWebcamButton;
let webcamRunning = false;
const videoHeight = "480px";
const videoWidth = "640px";
// Before we can use PoseLandmarker class we must wait for it to finish
// loading. Machine Learning models can be large and take a moment to
// get everything needed to run.
const createPoseLandmarker = async () => {
    const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm");
    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
        baseOptions: {
            modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task`,
            delegate: "GPU"
        },
        runningMode: runningMode,
        numPoses: 2
    });
    demosSection.classList.remove("invisible");
};
createPoseLandmarker();
/********************************************************************
// Demo 1: Grab a bunch of images from the page and detection them
// upon click.
********************************************************************/
// In this demo, we have put all our clickable images in divs with the
// CSS class 'detectionOnClick'. Lets get all the elements that have
// this class.
const imageContainers = document.getElementsByClassName("detectOnClick");


// Now let's go through all of these and add a click event listener.
for (let i = 0; i < imageContainers.length; i++) {
    // Add event listener to the child element whichis the img element.
    imageContainers[i].children[0].addEventListener("click", handleClick);
}
// When an image is clicked, let's detect it and display results!
async function handleClick(event) {
    if (!poseLandmarker) {
        console.log("Wait for poseLandmarker to load before clicking!");
        return;
    }
    if (runningMode === "VIDEO") {
        runningMode = "IMAGE";
        await poseLandmarker.setOptions({ runningMode: "IMAGE" });
    }
    // Remove all landmarks drawed before
    const allCanvas = event.target.parentNode.getElementsByClassName("canvas");
    for (var i = allCanvas.length - 1; i >= 0; i--) {
        const n = allCanvas[i];
        n.parentNode.removeChild(n);
    }
    // We can call poseLandmarker.detect as many times as we like with
    // different image data each time. The result is returned in a callback.
    poseLandmarker.detect(event.target, (result) => {
        const canvas = document.createElement("canvas");
        canvas.setAttribute("class", "canvas");
        canvas.setAttribute("width", event.target.naturalWidth + "px");
        canvas.setAttribute("height", event.target.naturalHeight + "px");
        canvas.style =
            "left: 0px;" +
                "top: 0px;" +
                "width: " +
                event.target.width +
                "px;" +
                "height: " +
                event.target.height +
                "px;";
        event.target.parentNode.appendChild(canvas);
        const canvasCtx = canvas.getContext("2d");
        const drawingUtils = new DrawingUtils(canvasCtx);
        for (const landmark of result.landmarks) {
            drawingUtils.drawLandmarks(landmark, {
                radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1)
            });
            drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
            const rightShoulder = landmark[11]; // Índice 11 é o ombro direito
            const leftShoulder = landmark[12];  // Índice 12 é o ombro esquerdo
            const altura_cima = landmark[2]
            const altura_baixo = landmark[31]
            function euclideanDistance(point1, point2) {
              const dx = point1.x - point2.x;
              const dy = point1.y - point2.y;
              return Math.sqrt(dx * dx + dy * dy);
            }
            let imageWidth = parseInt(document.getElementById('imagePreview').width)
            console.log(imageWidth)
            const distance = euclideanDistance(rightShoulder, leftShoulder);
            const distancePixels = distance * parseInt(canvasElement.width)
            console.log(distancePixels)
            const personHeightCm = parseInt(prompt('Insira sua altura (cm):'));
            const personHeightPixels = euclideanDistance(altura_cima, altura_baixo) * canvasElement.height;
            console.log(personHeightPixels)
            const distanceCm = (distancePixels / personHeightPixels) * personHeightCm;

            document.getElementById('med-ombro').innerHTML = distanceCm;
        }
        console.log(canvas)
    });
}
/********************************************************************
// Demo 2: Continuously grab image from webcam stream and detect it.
********************************************************************/
const video = document.getElementById("webcam");
const canvasElement = document.getElementById("output_canvas");
const canvasCtx = canvasElement.getContext("2d");
const drawingUtils = new DrawingUtils(canvasCtx);
// Check if webcam access is supported.
const hasGetUserMedia = () => { var _a; return !!((_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.getUserMedia); };
// If webcam supported, add event listener to button for when user
// wants to activate it.
if (hasGetUserMedia()) {
    enableWebcamButton = document.getElementById("webcamButton");
    enableWebcamButton.addEventListener("click", enableCam);
}
else {
    console.warn("getUserMedia() is not supported by your browser");
}
// Enable the live webcam view and start detection.
function enableCam(event) {
    if (!poseLandmarker) {
        console.log("Wait! poseLandmaker not loaded yet.");
        return;
    }
    if (webcamRunning === true) {
        webcamRunning = false;
        enableWebcamButton.innerText = "ENABLE PREDICTIONS";
    }
    else {
        webcamRunning = true;
        enableWebcamButton.innerText = "DISABLE PREDICTIONS";
    }
    // getUsermedia parameters.
    const constraints = {
        video: true
    };
    // Activate the webcam stream.
    navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
        video.srcObject = stream;
        video.addEventListener("loadeddata", predictWebcam);
    });
}
let lastVideoTime = -1;
async function predictWebcam() {

    canvasElement.style.height = videoHeight;
    video.style.height = videoHeight;
    canvasElement.style.width = videoWidth;
    video.style.width = videoWidth;
    // Now let's start detecting the stream.
    if (runningMode === "IMAGE") {
        runningMode = "VIDEO";
        await poseLandmarker.setOptions({ runningMode: "VIDEO" });
    }
    let startTimeMs = performance.now();
    if (lastVideoTime !== video.currentTime) {
        lastVideoTime = video.currentTime;
        poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            for (const landmark of result.landmarks) {
                drawingUtils.drawLandmarks(landmark, {
                    radius: (data) => DrawingUtils.lerp(data.from.z, -0.15, 0.1, 5, 1)
                });
                drawingUtils.drawConnectors(landmark, PoseLandmarker.POSE_CONNECTIONS);
            }
            canvasCtx.restore();
        });
    }
    // Call this function again to keep predicting when the browser is ready.
    if (webcamRunning === true) {
        window.requestAnimationFrame(predictWebcam);
    }
}
  </script>
</body>
</html>
